import {
  camelize,
  computed,
  createElementBlock,
  defineComponent,
  getCurrentInstance,
  inject,
  nextTick,
  onMounted,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  ref,
  renderSlot,
  toRaw,
  toRefs,
  watch,
  watchEffect
} from "./chunk-5K66ZFVY.js";
import {
  Annotations,
  Area,
  Axis,
  Brush,
  BulletLegend,
  ChordDiagram,
  Crosshair,
  Donut,
  FreeBrush,
  Graph,
  GroupedBar,
  LeafletFlowMap,
  LeafletMap,
  Line,
  NestedDonut,
  Sankey,
  Scatter,
  SingleContainer,
  StackedBar,
  Timeline,
  Tooltip,
  TopoJSONMap,
  XYContainer,
  XYLabels
} from "./chunk-FDVFLFIP.js";
import {
  isEqual
} from "./chunk-MKT7XV5Q.js";
import "./chunk-AXVSVYA2.js";
import "./chunk-PR4QN5HX.js";

// node_modules/@unovis/vue/utils/context.js
var o = Symbol("componentAccessorKey");
var s = Symbol("tooltipAccessorKey");
var c = Symbol("crosshairAccessorKey");
var e = Symbol("axisAccessorKey");
var t = Symbol("annotationsAccessorKey");

// node_modules/@unovis/vue/utils/props.js
function f(t2, r) {
  return isEqual(t2, r);
}
function m(t2) {
  const r = getCurrentInstance(), n = r.attrs;
  return computed(() => {
    const o2 = {}, c2 = (r == null ? void 0 : r.vnode.props) ?? {};
    return Object.keys(c2).forEach((e2) => {
      o2[camelize(e2)] = t2[camelize(e2)];
    }), { ...o2, ...n };
  });
}

// node_modules/@unovis/vue/containers/xy-container/index.js
var $ = defineComponent({
  __name: "index",
  props: {
    components: {},
    xScale: { type: [Object, Function] },
    xDomain: {},
    xDomainMinConstraint: {},
    xDomainMaxConstraint: {},
    xRange: {},
    yScale: { type: [Object, Function] },
    yDomain: {},
    yDomainMinConstraint: {},
    yDomainMaxConstraint: {},
    yRange: {},
    yDirection: {},
    xAxis: {},
    yAxis: {},
    autoMargin: { type: Boolean },
    tooltip: {},
    crosshair: {},
    preventEmptyDomain: { type: [Boolean, null] },
    scaleByDomain: { type: Boolean },
    annotations: {},
    duration: {},
    margin: {},
    padding: {},
    sizing: {},
    width: {},
    height: {},
    svgDefs: {},
    ariaLabel: {},
    data: {}
  },
  setup(d, { expose: l }) {
    const c2 = d, { data: t2 } = toRefs(c2), m2 = m(c2), n = ref(), e2 = reactive({
      components: [],
      annotations: void 0,
      crosshair: void 0,
      tooltip: void 0,
      xAxis: void 0,
      yAxis: void 0
    }), s2 = ref();
    return watch(t2, () => {
      n.value && n.value.setData(t2.value, true);
    }), watchEffect(() => {
      var o2;
      e2.components.map((i) => i.config), (o2 = n.value) == null || o2.updateContainer({ ...toRaw(m2.value), ...toRaw(e2) });
    }), onMounted(() => {
      s2.value && (n.value = new XYContainer(s2.value, { ...toRaw(e2) }, t2.value));
    }), onUnmounted(() => {
      var o2;
      return (o2 = n.value) == null ? void 0 : o2.destroy();
    }), provide(o, {
      data: t2,
      update: (o2) => e2.components = [...e2.components, o2],
      destroy: () => {
        var o2;
        return e2.components = (o2 = e2.components) == null ? void 0 : o2.filter((i) => !i.isDestroyed());
      }
    }), provide(e, {
      data: t2,
      update: (o2) => e2[`${o2.config.type}Axis`] = o2,
      destroy: (o2) => {
        e2[`${o2}Axis`] = void 0;
      }
    }), provide(c, {
      data: t2,
      update: (o2) => e2.crosshair = o2,
      destroy: () => {
        e2.crosshair = void 0;
      }
    }), provide(s, {
      data: t2,
      update: (o2) => e2.tooltip = o2,
      destroy: () => {
        e2.tooltip = void 0;
      }
    }), provide(t, {
      data: t2,
      update: (o2) => e2.annotations = o2,
      destroy: () => {
        e2.annotations = void 0;
      }
    }), l({
      component: n
    }), (o2, i) => (openBlock(), createElementBlock("div", {
      "data-vis-xy-container": "",
      ref_key: "elRef",
      ref: s2,
      class: "unovis-xy-container"
    }, [
      renderSlot(o2.$slots, "default")
    ], 512));
  }
});

// node_modules/@unovis/vue/containers/single-container/index.js
var b = defineComponent({
  __name: "index",
  props: {
    component: {},
    tooltip: {},
    annotations: {},
    duration: {},
    margin: {},
    padding: {},
    sizing: {},
    width: {},
    height: {},
    svgDefs: {},
    ariaLabel: {},
    data: {}
  },
  setup(c2, { expose: d }) {
    const r = c2, { data: n } = toRefs(r), l = m(r);
    let o2;
    const e2 = reactive({
      component: void 0,
      tooltip: void 0,
      annotations: void 0
    }), i = ref(), p = () => {
      o2 || i.value && e2.component && (o2 = new SingleContainer(i.value, { ...toRaw(e2) }, n.value));
    };
    return watchEffect(() => {
      var t2;
      p(), (t2 = e2.component) == null || t2.config, o2 == null || o2.updateContainer({ ...toRaw(l.value), ...toRaw(e2) });
    }), watch(n, () => {
      o2 ? o2.setData(n.value, true) : p();
    }), onUnmounted(() => o2 == null ? void 0 : o2.destroy()), provide(o, {
      data: n,
      update: (t2) => e2.component = t2,
      destroy: () => e2.component = void 0
    }), provide(s, {
      data: n,
      update: (t2) => e2.tooltip = t2,
      destroy: () => {
        e2.tooltip = void 0;
      }
    }), provide(t, {
      data: n,
      update: (t2) => e2.annotations = t2,
      destroy: () => {
        e2.annotations = void 0;
      }
    }), d({
      component: o2
    }), (t2, B6) => (openBlock(), createElementBlock("div", {
      "data-vis-single-container": "",
      ref_key: "elRef",
      ref: i,
      class: "unovis-single-container"
    }, [
      renderSlot(t2.$slots, "default")
    ], 512));
  }
});

// node_modules/@unovis/vue/components/area/index.js
var h = { "data-vis-component": "" };
var w = Area.selectors;
var C = defineComponent({
  __name: "index",
  props: {
    color: { type: [Function, String, Array, null] },
    curveType: {},
    baseline: { type: [Function, Number, null] },
    opacity: { type: [Function, Number, null] },
    cursor: { type: [Function, String, null] },
    minHeight1Px: { type: Boolean },
    x: { type: [Function, Number, null] },
    y: { type: [Function, Number, null, Array] },
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(s2, { expose: p }) {
    const c2 = s2, o2 = inject(o), n = computed(() => o2.data.value ?? c2.data), a = m(c2), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Area(a.value), (e2 = t2.value) == null || e2.setData(n.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(a, (e2, r) => {
      var u;
      f(e2, r) || (u = t2.value) == null || u.setConfig(a.value);
    }), watch(n, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(n.value);
    }), p({
      component: t2
    }), (e2, r) => (openBlock(), createElementBlock("div", h));
  }
});

// node_modules/@unovis/vue/components/axis/index.js
var _ = { "data-vis-axis": "" };
var M = Axis.selectors;
var j = defineComponent({
  __name: "index",
  props: {
    position: {},
    type: {},
    fullSize: { type: Boolean },
    label: {},
    labelFontSize: {},
    labelMargin: {},
    labelColor: {},
    gridLine: { type: Boolean },
    tickLine: { type: Boolean },
    domainLine: { type: Boolean },
    minMaxTicksOnly: { type: Boolean },
    tickFormat: { type: Function },
    tickValues: {},
    numTicks: {},
    tickTextFitMode: {},
    tickTextWidth: {},
    tickTextSeparator: {},
    tickTextForceWordBreak: { type: Boolean },
    tickTextTrimType: {},
    tickTextFontSize: {},
    tickTextAlign: {},
    tickTextColor: {},
    tickPadding: {},
    x: { type: [Function, Number, null] },
    y: { type: [Function, Number, null, Array] },
    id: { type: Function },
    color: { type: [Function, String, Array, null] },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(u, { expose: p }) {
    const o2 = u, n = inject(e), a = computed(() => n.data.value ?? o2.data), i = m(o2), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Axis(i.value), (e2 = t2.value) == null || e2.setData(a.value), n.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), n.destroy(o2.type);
    }), watch(i, (e2, c2) => {
      var l;
      f(e2, c2) || (l = t2.value) == null || l.setConfig(i.value);
    }), watch(a, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(a.value);
    }), p({
      component: t2
    }), (e2, c2) => (openBlock(), createElementBlock("div", _));
  }
});

// node_modules/@unovis/vue/components/brush/index.js
var S = { "data-vis-component": "" };
var C2 = Brush.selectors;
var D = defineComponent({
  __name: "index",
  props: {
    onBrush: { type: Function },
    onBrushStart: { type: Function },
    onBrushMove: { type: Function },
    onBrushEnd: { type: Function },
    handleWidth: {},
    selection: {},
    draggable: { type: Boolean },
    handlePosition: {},
    selectionMinLength: {},
    x: { type: [Function, Number, null] },
    y: { type: [Function, Number, null, Array] },
    id: { type: Function },
    color: { type: [Function, String, Array, null] },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(l, { expose: p }) {
    const c2 = l, o2 = inject(o), n = computed(() => o2.data.value ?? c2.data), a = m(c2), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Brush(a.value), (e2 = t2.value) == null || e2.setData(n.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(a, (e2, r) => {
      var u;
      f(e2, r) || (u = t2.value) == null || u.setConfig(a.value);
    }), watch(n, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(n.value);
    }), p({
      component: t2
    }), (e2, r) => (openBlock(), createElementBlock("div", S));
  }
});

// node_modules/@unovis/vue/components/crosshair/index.js
var B = { "data-vis-crosshair": "" };
var q = Crosshair.selectors;
var A = defineComponent({
  __name: "index",
  props: {
    data: {}
  },
  setup(l, { expose: p }) {
    const r = l, t2 = inject(c), a = computed(() => t2.data.value ?? r.data), s2 = m(r), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        o2.value = new Crosshair(s2.value), (e2 = o2.value) == null || e2.setData(a.value), t2.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), t2.destroy();
    }), watch(s2, (e2, n) => {
      var c2;
      f(e2, n) || (c2 = o2.value) == null || c2.setConfig(s2.value);
    }), watch(a, () => {
      var e2;
      (e2 = o2.value) == null || e2.setData(a.value);
    }), p({
      component: o2
    }), (e2, n) => (openBlock(), createElementBlock("div", B));
  }
});

// node_modules/@unovis/vue/components/free-brush/index.js
var g = { "data-vis-component": "" };
var C3 = FreeBrush.selectors;
var D2 = defineComponent({
  __name: "index",
  props: {
    mode: {},
    onBrush: { type: Function },
    onBrushStart: { type: Function },
    onBrushMove: { type: Function },
    onBrushEnd: { type: Function },
    handleWidth: {},
    selection: {},
    selectionMinLength: {},
    autoHide: { type: Boolean },
    x: { type: [Function, Number, null] },
    y: { type: [Function, Number, null, Array] },
    id: { type: Function },
    color: { type: [Function, String, Array, null] },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(l, { expose: p }) {
    const c2 = l, o2 = inject(o), n = computed(() => o2.data.value ?? c2.data), a = m(c2), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new FreeBrush(a.value), (e2 = t2.value) == null || e2.setData(n.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(a, (e2, r) => {
      var u;
      f(e2, r) || (u = t2.value) == null || u.setConfig(a.value);
    }), watch(n, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(n.value);
    }), p({
      component: t2
    }), (e2, r) => (openBlock(), createElementBlock("div", g));
  }
});

// node_modules/@unovis/vue/components/grouped-bar/index.js
var S2 = { "data-vis-component": "" };
var w2 = GroupedBar.selectors;
var A2 = defineComponent({
  __name: "index",
  props: {
    color: { type: [Function, String, Array, null] },
    groupWidth: {},
    groupMaxWidth: {},
    dataStep: {},
    groupPadding: {},
    barPadding: {},
    roundedCorners: { type: [Number, Boolean] },
    barMinHeight: {},
    cursor: { type: [Function, String, null] },
    orientation: {},
    x: { type: [Function, Number, null] },
    y: { type: [Function, Number, null, Array] },
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(p, { expose: l }) {
    const r = p, o2 = inject(o), n = computed(() => o2.data.value ?? r.data), a = m(r), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new GroupedBar(a.value), (e2 = t2.value) == null || e2.setData(n.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(a, (e2, u) => {
      var c2;
      f(e2, u) || (c2 = t2.value) == null || c2.setConfig(a.value);
    }), watch(n, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(n.value);
    }), l({
      component: t2
    }), (e2, u) => (openBlock(), createElementBlock("div", S2));
  }
});

// node_modules/@unovis/vue/components/line/index.js
var k = { "data-vis-component": "" };
var w3 = Line.selectors;
var C4 = defineComponent({
  __name: "index",
  props: {
    color: { type: [Function, String, Array, null] },
    curveType: {},
    lineWidth: {},
    lineDashArray: { type: [Function, null] },
    fallbackValue: {},
    highlightOnHover: { type: Boolean },
    cursor: { type: [Function, String, null] },
    x: { type: [Function, Number, null] },
    y: { type: [Function, Number, null, Array] },
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(s2, { expose: p }) {
    const c2 = s2, n = inject(o), o2 = computed(() => n.data.value ?? c2.data), a = m(c2), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Line(a.value), (e2 = t2.value) == null || e2.setData(o2.value), n.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), n.destroy();
    }), watch(a, (e2, r) => {
      var u;
      f(e2, r) || (u = t2.value) == null || u.setConfig(a.value);
    }), watch(o2, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(o2.value);
    }), p({
      component: t2
    }), (e2, r) => (openBlock(), createElementBlock("div", k));
  }
});

// node_modules/@unovis/vue/components/scatter/index.js
var k2 = { "data-vis-component": "" };
var N = Scatter.selectors;
var O = defineComponent({
  __name: "index",
  props: {
    color: { type: [Function, String, Array, null] },
    size: { type: [Function, Number, null] },
    sizeScale: { type: [Object, Function] },
    sizeRange: {},
    shape: { type: [Function, String] },
    label: { type: [Function, String, null] },
    labelColor: { type: [Function, String, Array, null] },
    labelHideOverlapping: { type: Boolean },
    cursor: { type: [Function, String, null] },
    labelTextBrightnessRatio: {},
    labelPosition: { type: [Function, null] },
    strokeColor: { type: [Function, String, Array, null] },
    strokeWidth: { type: [Function, Number, null] },
    x: { type: [Function, Number, null] },
    y: { type: [Function, Number, null, Array] },
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(s2, { expose: p }) {
    const l = s2, n = inject(o), o2 = computed(() => n.data.value ?? l.data), a = m(l), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Scatter(a.value), (e2 = t2.value) == null || e2.setData(o2.value), n.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), n.destroy();
    }), watch(a, (e2, r) => {
      var c2;
      f(e2, r) || (c2 = t2.value) == null || c2.setConfig(a.value);
    }), watch(o2, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(o2.value);
    }), p({
      component: t2
    }), (e2, r) => (openBlock(), createElementBlock("div", k2));
  }
});

// node_modules/@unovis/vue/components/stacked-bar/index.js
var B2 = { "data-vis-component": "" };
var j2 = StackedBar.selectors;
var w4 = defineComponent({
  __name: "index",
  props: {
    color: { type: [Function, String, Array, null] },
    barWidth: {},
    barMaxWidth: {},
    dataStep: {},
    barPadding: {},
    roundedCorners: { type: [Number, Boolean] },
    cursor: { type: [Function, String, null] },
    barMinHeight1Px: { type: Boolean },
    barMinHeightZeroValue: {},
    orientation: {},
    x: { type: [Function, Number, null] },
    y: { type: [Function, Number, null, Array] },
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(s2, { expose: p }) {
    const r = s2, o2 = inject(o), n = computed(() => o2.data.value ?? r.data), a = m(r), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new StackedBar(a.value), (e2 = t2.value) == null || e2.setData(n.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(a, (e2, c2) => {
      var u;
      f(e2, c2) || (u = t2.value) == null || u.setConfig(a.value);
    }), watch(n, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(n.value);
    }), p({
      component: t2
    }), (e2, c2) => (openBlock(), createElementBlock("div", B2));
  }
});

// node_modules/@unovis/vue/components/timeline/index.js
var B3 = { "data-vis-component": "" };
var j3 = Timeline.selectors;
var q2 = defineComponent({
  __name: "index",
  props: {
    data: {}
  },
  setup(l, { expose: p }) {
    const s2 = l, t2 = inject(o), a = computed(() => t2.data.value ?? s2.data), n = m(s2), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        o2.value = new Timeline(n.value), (e2 = o2.value) == null || e2.setData(a.value), t2.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), t2.destroy();
    }), watch(n, (e2, c2) => {
      var r;
      f(e2, c2) || (r = o2.value) == null || r.setConfig(n.value);
    }), watch(a, () => {
      var e2;
      (e2 = o2.value) == null || e2.setData(a.value);
    }), p({
      component: o2
    }), (e2, c2) => (openBlock(), createElementBlock("div", B3));
  }
});

// node_modules/@unovis/vue/components/xy-labels/index.js
var B4 = { "data-vis-component": "" };
var N2 = XYLabels.selectors;
var P = defineComponent({
  __name: "index",
  props: {
    color: { type: [Function, String, Array, null] },
    y: { type: [Function, Number, null] },
    xPositioning: { type: [Function, null] },
    yPositioning: { type: [Function, null] },
    labelFontSize: { type: [Function, Number, null] },
    label: { type: [Function, String, null] },
    backgroundColor: { type: [Function, String, Array, null] },
    cursor: { type: [Function, String, null] },
    labelTextBrightnessRatio: {},
    clustering: { type: Boolean },
    clusterLabel: { type: [Function, String, null] },
    clusterFontSize: { type: [Function, Number, null] },
    clusterBackgroundColor: { type: [Function, String, Array, null] },
    clusterCursor: { type: [Function, String, null] },
    clusterLabelColor: { type: [Function, String, Array, null] },
    x: { type: [Function, Number, null] },
    id: { type: Function },
    xScale: { type: [Object, Function] },
    yScale: { type: [Object, Function] },
    excludeFromDomainCalculation: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(s2, { expose: p }) {
    const u = s2, n = inject(o), o2 = computed(() => n.data.value ?? u.data), l = m(u), e2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var t2;
        e2.value = new XYLabels(l.value), (t2 = e2.value) == null || t2.setData(o2.value), n.update(e2.value);
      });
    }), onUnmounted(() => {
      var t2;
      (t2 = e2.value) == null || t2.destroy(), n.destroy();
    }), watch(l, (t2, r) => {
      var c2;
      f(t2, r) || (c2 = e2.value) == null || c2.setConfig(l.value);
    }), watch(o2, () => {
      var t2;
      (t2 = e2.value) == null || t2.setData(o2.value);
    }), p({
      component: e2
    }), (t2, r) => (openBlock(), createElementBlock("div", B4));
  }
});

// node_modules/@unovis/vue/components/chord-diagram/index.js
var x = { "data-vis-component": "" };
var w5 = ChordDiagram.selectors;
var E = defineComponent({
  __name: "index",
  props: {
    angleRange: {},
    cornerRadius: { type: [Function, Number, null] },
    highlightedNodeId: {},
    highlightedLinkIds: {},
    linkColor: { type: [Function, String, Array, null] },
    linkValue: { type: [Function, Number, null] },
    nodeLevels: {},
    nodeWidth: {},
    nodeColor: { type: [Function, String, Array, null] },
    nodeLabel: { type: [Function, String, null] },
    nodeLabelColor: { type: [Function, String, null] },
    nodeLabelAlignment: { type: [Function, null] },
    padAngle: {},
    radiusScaleExponent: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(s2, { expose: d }) {
    const r = s2, t2 = inject(o), o2 = computed(() => t2.data.value ?? r.data), a = m(r), n = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        n.value = new ChordDiagram(a.value), (e2 = n.value) == null || e2.setData(o2.value), t2.update(n.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = n.value) == null || e2.destroy(), t2.destroy();
    }), watch(a, (e2, l) => {
      var i;
      f(e2, l) || (i = n.value) == null || i.setConfig(a.value);
    }), watch(o2, () => {
      var e2;
      (e2 = n.value) == null || e2.setData(o2.value);
    }), d({
      component: n
    }), (e2, l) => (openBlock(), createElementBlock("div", x));
  }
});

// node_modules/@unovis/vue/components/donut/index.js
var k3 = { "data-vis-component": "" };
var E2 = Donut.selectors;
var L = defineComponent({
  __name: "index",
  props: {
    id: { type: Function },
    value: { type: [Function, Number, null] },
    angleRange: {},
    padAngle: {},
    sortFunction: { type: Function },
    cornerRadius: {},
    color: { type: [Function, String, Array, null] },
    radius: {},
    arcWidth: {},
    centralLabel: {},
    centralSubLabel: {},
    centralSubLabelWrap: { type: Boolean },
    showEmptySegments: { type: Boolean },
    emptySegmentAngle: {},
    showBackground: { type: Boolean },
    backgroundAngleRange: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(p, { expose: i }) {
    const r = p, o2 = inject(o), n = computed(() => o2.data.value ?? r.data), a = m(r), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new Donut(a.value), (e2 = t2.value) == null || e2.setData(n.value), o2.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), o2.destroy();
    }), watch(a, (e2, c2) => {
      var s2;
      f(e2, c2) || (s2 = t2.value) == null || s2.setConfig(a.value);
    }), watch(n, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(n.value);
    }), i({
      component: t2
    }), (e2, c2) => (openBlock(), createElementBlock("div", k3));
  }
});

// node_modules/@unovis/vue/components/graph/index.js
var v = { "data-vis-component": "" };
var T = Graph.selectors;
var D3 = defineComponent({
  __name: "index",
  props: {
    zoomScaleExtent: {},
    disableZoom: { type: Boolean },
    disableDrag: { type: Boolean },
    zoomThrottledUpdateNodeThreshold: {},
    layoutType: {},
    layoutAutofit: { type: Boolean },
    layoutAutofitTolerance: {},
    layoutNonConnectedAside: { type: Boolean },
    layoutNodeGroup: { type: [Function, String, null] },
    layoutGroupOrder: {},
    layoutParallelNodesPerColumn: {},
    layoutParallelNodeSubGroup: { type: [Function, String, null] },
    layoutParallelSubGroupsPerRow: {},
    layoutParallelGroupSpacing: {},
    layoutParallelSortConnectionsByGroup: {},
    forceLayoutSettings: {},
    dagreLayoutSettings: {},
    layoutElkSettings: { type: [Function, null] },
    layoutElkNodeGroups: {},
    linkWidth: { type: [Function, Number, null] },
    linkStyle: { type: [Function, null] },
    linkBandWidth: { type: [Function, Number, null] },
    linkArrow: { type: [Function, null] },
    linkStroke: { type: [Function, String, Array, null] },
    linkDisabled: { type: [Function, Boolean, null] },
    linkFlow: { type: [Function, Boolean, null] },
    linkFlowAnimDuration: {},
    linkFlowParticleSize: {},
    linkLabel: { type: [Function, null] },
    linkLabelShiftFromCenter: { type: [Function, Boolean, null] },
    linkNeighborSpacing: {},
    linkCurvature: { type: [Function, Number, null] },
    selectedLinkId: {},
    nodeSize: { type: [Function, Number, null] },
    nodeStrokeWidth: { type: [Function, Number, null] },
    nodeShape: { type: [Function, null] },
    nodeGaugeValue: { type: [Function, Number, null] },
    nodeGaugeFill: { type: [Function, String, Array, null] },
    nodeGaugeAnimDuration: {},
    nodeIcon: { type: [Function, String, null] },
    nodeIconSize: { type: [Function, Number, null] },
    nodeLabel: { type: [Function, String, null] },
    nodeLabelTrim: { type: [Function, Boolean, null] },
    nodeLabelTrimMode: { type: [Function, null] },
    nodeLabelTrimLength: { type: [Function, Number, null] },
    nodeSubLabel: { type: [Function, String, null] },
    nodeSubLabelTrim: { type: [Function, Boolean, null] },
    nodeSubLabelTrimMode: { type: [Function, null] },
    nodeSubLabelTrimLength: { type: [Function, Number, null] },
    nodeSideLabels: { type: [Function, null] },
    nodeBottomIcon: { type: [Function, String, null] },
    nodeDisabled: { type: [Function, Boolean, null] },
    nodeFill: { type: [Function, String, Array, null] },
    nodeStroke: { type: [Function, String, Array, null] },
    nodeSort: { type: Function },
    nodeEnterPosition: { type: [Function, null] },
    nodeEnterScale: { type: [Function, Number, null] },
    nodeExitPosition: { type: [Function, null] },
    nodeExitScale: { type: [Function, Number, null] },
    selectedNodeId: {},
    panels: {},
    onNodeDragStart: { type: Function },
    onNodeDrag: { type: Function },
    onNodeDragEnd: { type: Function },
    onZoom: { type: Function },
    onLayoutCalculated: { type: Function },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(p, { expose: d }) {
    const u = p, o2 = inject(o), t2 = computed(() => o2.data.value ?? u.data), l = m(u), e2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var n;
        e2.value = new Graph(l.value), (n = e2.value) == null || n.setData(t2.value), o2.update(e2.value);
      });
    }), onUnmounted(() => {
      var n;
      (n = e2.value) == null || n.destroy(), o2.destroy();
    }), watch(l, (n, i) => {
      var a;
      f(n, i) || (a = e2.value) == null || a.setConfig(l.value);
    }), watch(t2, () => {
      var n;
      (n = e2.value) == null || n.setData(t2.value);
    }), d({
      component: e2
    }), (n, i) => (openBlock(), createElementBlock("div", v));
  }
});

// node_modules/@unovis/vue/components/nested-donut/index.js
var F = { "data-vis-component": "" };
var C5 = NestedDonut.selectors;
var D4 = defineComponent({
  __name: "index",
  props: {
    angleRange: {},
    direction: {},
    value: { type: [Function, Number, null] },
    centralLabel: {},
    centralSubLabel: {},
    centralSubLabelWrap: { type: Boolean },
    showBackground: { type: Boolean },
    sort: { type: Function },
    layers: {},
    layerSettings: { type: [Function, null] },
    layerPadding: {},
    cornerRadius: {},
    emptySegmentAngle: {},
    hideOverflowingSegmentLabels: { type: Boolean },
    segmentColor: { type: [Function, String, Array, null] },
    segmentLabel: { type: [Function, String, null] },
    segmentLabelColor: { type: [Function, String, Array, null] },
    showEmptySegments: { type: Boolean },
    showSegmentLabels: { type: Boolean },
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(i, { expose: p }) {
    const r = i, n = inject(o), o2 = computed(() => n.data.value ?? r.data), a = m(r), t2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        t2.value = new NestedDonut(a.value), (e2 = t2.value) == null || e2.setData(o2.value), n.update(t2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = t2.value) == null || e2.destroy(), n.destroy();
    }), watch(a, (e2, l) => {
      var s2;
      f(e2, l) || (s2 = t2.value) == null || s2.setConfig(a.value);
    }), watch(o2, () => {
      var e2;
      (e2 = t2.value) == null || e2.setData(o2.value);
    }), p({
      component: t2
    }), (e2, l) => (openBlock(), createElementBlock("div", F));
  }
});

// node_modules/@unovis/vue/components/sankey/index.js
var C6 = { "data-vis-component": "" };
var L2 = Sankey.selectors;
var H = defineComponent({
  __name: "index",
  props: {
    id: { type: Function },
    heightNormalizationCoeff: {},
    exitTransitionType: {},
    enterTransitionType: {},
    highlightSubtreeOnHover: { type: Boolean },
    highlightDuration: {},
    highlightDelay: {},
    iterations: {},
    nodeSort: { type: [Function, null] },
    linkSort: { type: [Function, null] },
    nodeWidth: {},
    nodeAlign: {},
    nodeHorizontalSpacing: {},
    nodeMinHeight: {},
    nodeMaxHeight: {},
    nodePadding: {},
    showSingleNode: { type: Boolean },
    nodeCursor: { type: [Function, String, null] },
    nodeIcon: { type: [Function, String, null] },
    nodeColor: { type: [Function, String, Array, null] },
    nodeFixedValue: { type: [Function, Number, null] },
    nodeIconColor: { type: [Function, String, Array, null] },
    linkColor: { type: [Function, String, null] },
    linkValue: { type: [Function, Number, null] },
    linkCursor: { type: [Function, String, null] },
    label: { type: [Function, String, null] },
    subLabel: { type: [Function, String, null] },
    labelPosition: { type: [Function, null] },
    labelVerticalAlign: {},
    labelBackground: { type: Boolean },
    labelFit: {},
    labelMaxWidth: {},
    labelExpandTrimmedOnHover: { type: Boolean },
    labelTrimMode: {},
    labelFontSize: {},
    labelTextSeparator: {},
    labelForceWordBreak: { type: Boolean },
    labelColor: { type: [Function, String, Array, null] },
    labelCursor: { type: [Function, String, null] },
    labelVisibility: { type: Function },
    subLabelFontSize: {},
    subLabelColor: { type: [Function, String, Array, null] },
    subLabelPlacement: {},
    subLabelToLabelInlineWidthRatio: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(p, { expose: s2 }) {
    const i = p, t2 = inject(o), o2 = computed(() => t2.data.value ?? i.data), l = m(i), n = ref();
    return onMounted(() => {
      nextTick(() => {
        var e2;
        n.value = new Sankey(l.value), (e2 = n.value) == null || e2.setData(o2.value), t2.update(n.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = n.value) == null || e2.destroy(), t2.destroy();
    }), watch(l, (e2, a) => {
      var r;
      f(e2, a) || (r = n.value) == null || r.setConfig(l.value);
    }), watch(o2, () => {
      var e2;
      (e2 = n.value) == null || e2.setData(o2.value);
    }), s2({
      component: n
    }), (e2, a) => (openBlock(), createElementBlock("div", C6));
  }
});

// node_modules/@unovis/vue/components/topojson-map/index.js
var N3 = { "data-vis-component": "" };
var M2 = TopoJSONMap.selectors;
var j4 = defineComponent({
  __name: "index",
  props: {
    projection: { type: [Function, Object] },
    topojson: {},
    mapFeatureName: {},
    mapFitToPoints: { type: Boolean },
    zoomFactor: {},
    disableZoom: { type: Boolean },
    zoomExtent: {},
    zoomDuration: {},
    linkWidth: { type: [Function, Number, null] },
    linkColor: { type: [Function, String, Array, null] },
    linkCursor: { type: [Function, String, null] },
    linkId: { type: [Function, String, null] },
    linkSource: { type: Function },
    linkTarget: { type: Function },
    areaId: { type: [Function, String, null] },
    areaColor: { type: [Function, String, Array, null] },
    areaCursor: { type: [Function, String, null] },
    pointColor: { type: [Function, String, Array, null] },
    pointRadius: { type: [Function, Number, null] },
    pointStrokeWidth: { type: [Function, Number, null] },
    pointCursor: { type: [Function, String, null] },
    longitude: { type: [Function, Number, null] },
    latitude: { type: [Function, Number, null] },
    pointLabel: { type: [Function, String, null] },
    pointLabelPosition: {},
    pointLabelTextBrightnessRatio: {},
    pointId: { type: Function },
    heatmapMode: { type: Boolean },
    heatmapModeBlurStdDeviation: {},
    heatmapModeZoomLevelThreshold: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(c2, { expose: s2 }) {
    const a = c2, n = inject(o), e2 = computed(() => n.data.value ?? a.data), i = m(a), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        var t2;
        o2.value = new TopoJSONMap(i.value), (t2 = o2.value) == null || t2.setData(e2.value), n.update(o2.value);
      });
    }), onUnmounted(() => {
      var t2;
      (t2 = o2.value) == null || t2.destroy(), n.destroy();
    }), watch(i, (t2, r) => {
      var u;
      f(t2, r) || (u = o2.value) == null || u.setConfig(i.value);
    }), watch(e2, () => {
      var t2;
      (t2 = o2.value) == null || t2.setData(e2.value);
    }), s2({
      component: o2
    }), (t2, r) => (openBlock(), createElementBlock("div", N3));
  }
});

// node_modules/@unovis/vue/components/tooltip/index.js
var w6 = { "data-vis-tooltip": "" };
var B5 = Tooltip.selectors;
var C7 = defineComponent({
  __name: "index",
  props: {
    components: {},
    container: {},
    horizontalPlacement: {},
    horizontalShift: {},
    verticalPlacement: {},
    verticalShift: {},
    triggers: {},
    attributes: {},
    data: {}
  },
  setup(a, { expose: i }) {
    const l = a, n = inject(s), t2 = m(l), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        o2.value = new Tooltip(t2.value), n.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), n.destroy();
    }), watch(t2, (e2, r) => {
      var s2;
      f(e2, r) || (s2 = o2.value) == null || s2.setConfig(t2.value);
    }), i({
      component: o2
    }), (e2, r) => (openBlock(), createElementBlock("div", w6));
  }
});

// node_modules/@unovis/vue/components/annotations/index.js
var A3 = { "data-vis-annotations": "" };
var P2 = Annotations.selectors;
var b2 = defineComponent({
  __name: "index",
  props: {
    items: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(c2, { expose: i }) {
    const p = c2, n = inject(t), t2 = m(p), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        o2.value = new Annotations(t2.value), n.update(o2.value);
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy(), n.destroy();
    }), watch(t2, (e2, s2) => {
      var a;
      f(e2, s2) || (a = o2.value) == null || a.setConfig(t2.value);
    }), i({
      component: o2
    }), (e2, s2) => (openBlock(), createElementBlock("div", A3));
  }
});

// node_modules/@unovis/vue/html-components/leaflet-map/index.js
var k4 = LeafletMap.selectors;
var C8 = defineComponent({
  __name: "index",
  props: {
    width: {},
    height: {},
    flyToDuration: {},
    fitViewPadding: {},
    zoomDuration: {},
    initialBounds: {},
    fitBoundsOnUpdate: {},
    fitViewOnInit: { type: Boolean },
    fitViewOnUpdate: { type: Boolean },
    style: {},
    styleDarkTheme: {},
    accessToken: {},
    attribution: {},
    renderer: {},
    onMapInitialized: { type: Function },
    onMapMoveZoom: { type: Function },
    onMapMoveStart: { type: Function },
    onMapMoveEnd: { type: Function },
    onMapZoomStart: { type: Function },
    onMapZoomEnd: { type: Function },
    onMapClick: { type: Function },
    pointLongitude: { type: [Function, Number, null] },
    pointLatitude: { type: [Function, Number, null] },
    pointId: { type: [Function, String, null] },
    pointShape: { type: [Function, null] },
    pointColor: { type: [Function, String, Array, null] },
    pointRadius: { type: [Function, Number, null] },
    pointLabel: { type: [Function, String, null] },
    pointLabelColor: { type: [Function, String, null] },
    pointBottomLabel: { type: [Function, String, null] },
    pointCursor: { type: [Function, String, null] },
    pointRingWidth: {},
    selectedPointId: {},
    clusterColor: { type: [Function, String, Array, null] },
    clusterRadius: { type: [Function, Number, null] },
    clusterLabel: { type: [Function, String, null] },
    clusterLabelColor: { type: [Function, String, null] },
    clusterBottomLabel: { type: [Function, String, null] },
    clusterRingWidth: {},
    clusterBackground: { type: Boolean },
    clusterExpandOnClick: { type: Boolean },
    clusteringDistance: {},
    colorMap: {},
    topoJSONLayer: {},
    tooltip: {},
    ariaLabel: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(p, { expose: c2 }) {
    const i = p, s2 = computed(() => i.data), e2 = m(i), n = ref(), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        o2.value && (n.value = new LeafletMap(o2.value, e2.value, s2.value));
      });
    }), onUnmounted(() => {
      var t2;
      (t2 = n.value) == null || t2.destroy();
    }), watch(e2, (t2, l) => {
      var u;
      f(t2, l) || (u = n.value) == null || u.setConfig(e2.value);
    }), c2({
      component: n
    }), (t2, l) => (openBlock(), createElementBlock("div", {
      "data-vis-leaflet-map": "",
      ref_key: "elRef",
      ref: o2
    }, null, 512));
  }
});

// node_modules/@unovis/vue/html-components/leaflet-flow-map/index.js
var P3 = LeafletFlowMap.selectors;
var C9 = defineComponent({
  __name: "index",
  props: {
    sourceLongitude: { type: [Function, Number, null] },
    sourceLatitude: { type: [Function, Number, null] },
    targetLongitude: { type: [Function, Number, null] },
    targetLatitude: { type: [Function, Number, null] },
    sourcePointRadius: { type: [Function, Number, null] },
    sourcePointColor: { type: [Function, String, Array, null] },
    flowParticleColor: { type: [Function, String, Array, null] },
    flowParticleRadius: { type: [Function, Number, null] },
    flowParticleSpeed: { type: [Function, Number, null] },
    flowParticleDensity: { type: [Function, Number, null] },
    onSourcePointClick: { type: Function },
    onSourcePointMouseEnter: { type: Function },
    onSourcePointMouseLeave: { type: Function },
    width: {},
    height: {},
    flyToDuration: {},
    fitViewPadding: {},
    zoomDuration: {},
    initialBounds: {},
    fitBoundsOnUpdate: {},
    fitViewOnInit: { type: Boolean },
    fitViewOnUpdate: { type: Boolean },
    style: {},
    styleDarkTheme: {},
    accessToken: {},
    attribution: {},
    renderer: {},
    onMapInitialized: { type: Function },
    onMapMoveZoom: { type: Function },
    onMapMoveStart: { type: Function },
    onMapMoveEnd: { type: Function },
    onMapZoomStart: { type: Function },
    onMapZoomEnd: { type: Function },
    onMapClick: { type: Function },
    pointLongitude: { type: [Function, Number, null] },
    pointLatitude: { type: [Function, Number, null] },
    pointId: { type: [Function, String, null] },
    pointShape: { type: [Function, null] },
    pointColor: { type: [Function, String, Array, null] },
    pointRadius: { type: [Function, Number, null] },
    pointLabel: { type: [Function, String, null] },
    pointLabelColor: { type: [Function, String, null] },
    pointBottomLabel: { type: [Function, String, null] },
    pointCursor: { type: [Function, String, null] },
    pointRingWidth: {},
    selectedPointId: {},
    clusterColor: { type: [Function, String, Array, null] },
    clusterRadius: { type: [Function, Number, null] },
    clusterLabel: { type: [Function, String, null] },
    clusterLabelColor: { type: [Function, String, null] },
    clusterBottomLabel: { type: [Function, String, null] },
    clusterRingWidth: {},
    clusterBackground: { type: Boolean },
    clusterExpandOnClick: { type: Boolean },
    clusteringDistance: {},
    colorMap: {},
    topoJSONLayer: {},
    tooltip: {},
    ariaLabel: {},
    duration: {},
    events: {},
    attributes: {},
    data: {}
  },
  setup(c2, { expose: p }) {
    const i = c2, s2 = computed(() => i.data), e2 = m(i), n = ref(), o2 = ref();
    return onMounted(() => {
      nextTick(() => {
        o2.value && (n.value = new LeafletFlowMap(o2.value, e2.value, s2.value));
      });
    }), onUnmounted(() => {
      var t2;
      (t2 = n.value) == null || t2.destroy();
    }), watch(e2, (t2, u) => {
      var l;
      f(t2, u) || (l = n.value) == null || l.setConfig(e2.value);
    }), p({
      component: n
    }), (t2, u) => (openBlock(), createElementBlock("div", {
      "data-vis-leaflet-flow-map": "",
      ref_key: "elRef",
      ref: o2
    }, null, 512));
  }
});

// node_modules/@unovis/vue/html-components/bullet-legend/index.js
var F2 = BulletLegend.selectors;
var P4 = defineComponent({
  __name: "index",
  props: {
    items: {},
    labelClassName: {},
    onLegendItemClick: { type: Function },
    labelFontSize: {},
    labelMaxWidth: {},
    bulletSize: {},
    bulletShape: { type: [Function, null] },
    orientation: {},
    renderIntoProvidedDomNode: { type: Boolean },
    data: {}
  },
  setup(i, { expose: s2 }) {
    const l = i;
    computed(() => l.data);
    const t2 = m(l), o2 = ref(), n = ref();
    return onMounted(() => {
      nextTick(() => {
        n.value && (o2.value = new BulletLegend(n.value, { ...t2.value, renderIntoProvidedDomNode: true }));
      });
    }), onUnmounted(() => {
      var e2;
      (e2 = o2.value) == null || e2.destroy();
    }), watch(t2, (e2, a) => {
      var r;
      f(e2, a) || (r = o2.value) == null || r.update(t2.value);
    }), s2({
      component: o2
    }), (e2, a) => (openBlock(), createElementBlock("div", {
      "data-vis-bullet-legend": "",
      ref_key: "elRef",
      ref: n
    }, null, 512));
  }
});

// node_modules/@unovis/vue/index.js
(function() {
  "use strict";
  try {
    if (typeof document < "u") {
      var e2 = document.createElement("style");
      e2.appendChild(document.createTextNode(".unovis-xy-container,.unovis-single-container{display:block;position:relative;width:100%}[data-vis-leaflet-flow-map]{display:block;position:relative}[data-vis-bullet-legend]{display:block}[data-vis-leaflet-map]{display:block;position:relative}")), document.head.appendChild(e2);
    }
  } catch (i) {
    console.error("vite-plugin-css-injected-by-js", i);
  }
})();
export {
  b2 as VisAnnotations,
  P2 as VisAnnotationsSelectors,
  C as VisArea,
  w as VisAreaSelectors,
  j as VisAxis,
  M as VisAxisSelectors,
  D as VisBrush,
  C2 as VisBrushSelectors,
  P4 as VisBulletLegend,
  F2 as VisBulletLegendSelectors,
  E as VisChordDiagram,
  w5 as VisChordDiagramSelectors,
  A as VisCrosshair,
  q as VisCrosshairSelectors,
  L as VisDonut,
  E2 as VisDonutSelectors,
  D2 as VisFreeBrush,
  C3 as VisFreeBrushSelectors,
  D3 as VisGraph,
  T as VisGraphSelectors,
  A2 as VisGroupedBar,
  w2 as VisGroupedBarSelectors,
  C9 as VisLeafletFlowMap,
  P3 as VisLeafletFlowMapSelectors,
  C8 as VisLeafletMap,
  k4 as VisLeafletMapSelectors,
  C4 as VisLine,
  w3 as VisLineSelectors,
  D4 as VisNestedDonut,
  C5 as VisNestedDonutSelectors,
  H as VisSankey,
  L2 as VisSankeySelectors,
  O as VisScatter,
  N as VisScatterSelectors,
  b as VisSingleContainer,
  w4 as VisStackedBar,
  j2 as VisStackedBarSelectors,
  q2 as VisTimeline,
  j3 as VisTimelineSelectors,
  C7 as VisTooltip,
  B5 as VisTooltipSelectors,
  j4 as VisTopoJSONMap,
  M2 as VisTopoJSONMapSelectors,
  $ as VisXYContainer,
  P as VisXYLabels,
  N2 as VisXYLabelsSelectors
};
//# sourceMappingURL=@unovis_vue.js.map
